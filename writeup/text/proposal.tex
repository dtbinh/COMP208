\section{Introduction}
The proposed project is a simple, privacy oriented social network, which demands
zero security knowledge on behalf of its users. In order to ensure security and
privacy in the face of nation state adversaries the system must be unable spy on
its users even if it wants to or server operators are ordered to.

We feel that obscuring the content of messages isn't enough, because suspician
may, and often does, fall upon people not for what they say, but to whom they
are speaking\todo{citation needed}. Our system will therefore not merely hide
the content of messages, but the recipient of messages too. Hiding the fact that
an IP address sent a message is out of scope, but hiding which user/keypair did
so is in scope.

The system will provide the following functionality:
\begin{itemize}
\item A user may add friends
\item A user may IM with fellow users
\item A user may IM anonymously with fellow users
\item A user may post messages to all their friends on their wall (think FB)
\item A user may request to post messages to all of a friends friends on a
friends page (think FB wall, permission is required because a user cannot know
who their friend (or anyone) is friends with)
\end{itemize}

The server operator will have access to the following information:
\begin{itemize}
\item Which IP uploaded which message (although they will be ignorant of its
content)
\item Which IPs are connecting to the server as clients
\item What times a specific IP connects \footnote {While this will aid in tying
an IP address to a person, it is deemed acceptable because it is not useful
information unless the persons private key is compromised.}
\end{itemize}

A third party logging all traffic between all clients and a server will have
access to the following information: \todo{Talk about TLS, end-to-end crypto}
\begin{itemize}
\item Who connects to the server, whether they upload or downloand information
\footnote{size correlation attacks could be used here if the message content is
known}
\end{itemize}

The benefits we feel this system provides over current solutions are the
following:
\begin{itemize}
\item Server operators can not know who talks with whom
\item Server operators can not know the content of messages
\item Server operators can not know which message is intended for which user
\item Server operators can not know who is friends with whom
\item Third parties sniffing the connections can not know anything the server
operator cannot know (this isn't unique, but is worth stating).
\end{itemize}

In order to ensure nobody can tell who is talking with whom we will base our
security model on the idea of shared mailboxes, as seen in practice at
alt.anonymous.messages
\footnote{https://groups.google.com/forum/\#!forum/alt.anonymous.messages}.
In this model one posts a message by encryping it using the public key of the
recipient, and posting it in a public location. In this model one reads a
message by downloading all messages from that location, and attempting to
decrypt them all using ones private key. Our protocol will build atop this
simple premise, and the the server will be a mere repository of messages, the
real work occuring wholly in the client.

\section{Summary of protocol} \todo[noline]{pretty dataflow diagrams}
\textbf{Creating an account} is done by generating an RSA keypair, and choosing
a name. An unencrypted (but signed) message is then posted to the server
associating that keypair with that name. In this way, by knowing the public key
of someone, you may discover their name in the service, but not vice versa.\\

\textbf{Connecting for the first time} Every unencrypted message stored on the
server is downloaded(signed nicknames and nothing more) \footnote{clients use
bittorrent to lighten server load?} (if someone retroactivly grants you
permission to view something they publish it as a new message with an old
timestamp). At this time the local database contains only signed messages
claiming usernames. The public keys are not provided, these are of use only when
you learn the public key behind a name. The rationale for not providing public
keys is provided in the section regarding adding a friend. Messages posted
after your name was claimed will require downloading too, as once you claim a
name people may send you messages.\\

\textbf{Connecting subsequently} The client requests every message from the last
time they connected (sent by the client, not stored by the server) up to the
present. Decryptable messages are used to update the local DB, others are
discarded.\\

\textbf{Continued connection} During a session the client requests updates from
the server every 1-5 seconds (configurable by the user).\\

\textbf{Adding a friend} is performed by having a friend email (or otherwise
transfere) you their public key. This is input to the client, and it finds their
name (via public posting that occured when registering). You may now interact
with that person. They may not interact with you until they recieve your public
key.\footnote{This is the one part that will be difficult for normal users,
however any protocol by which the server stores and serves public keys is
entirely unsuitable as a MitM would be trivial on behalf of the server
operators}\\

\textbf{Talking with a friend or posting on your wall} is achieved by writing
a message, signing it with your private key, and encrypting one copy of it with
each of the recipiants public keys before posting it to the server. The client
prevents one from posting a message to someones public key, if they have not
claimed a nickname.\\

\textbf{Posting to a friends wall} may be requested by sending a specially
formated message to that friend (all handled by the GUI, like much else here),
when that friend logs in they will recieve your request to post on their wall
and may confirm or deny it. If they confirm then they take your (signed) message
and transmit it to each of their friends as previously described (authentication
is entirely based on crypto signatures, so it doesn't matter who posts the
message).\footnote{This is required because it is impossible for one to know who
their friends friends are.}

\section{Tasks and Challanges}
What would need to be done:
\begin{itemize}
\item  Server
    \begin{itemize}
    \item stores messages sent to it by clients
    \item sends stored messages to clients at request (either the whole lot, or
    messages from within a certain timeframe)
    \end{itemize}
\item Client
    \begin{itemize}
    \item handle decryption/encryption
    \item sends data to the server
    \item maintains a local DB built from decrpyted messages
    \item displays a nice GUI that hides everything from the user
    \end{itemize}
\end{itemize}

\subsection{Data Flow to Clients and Required Server Storage}
A estimate is hereafter given as to the size of all stored messages, and the
amount of data which would need downloading by each client when it is started.
The following assumptions are used:
\begin{itemize}
\item A users avarage message posted to their wall is ~200 characters
\item A users avarage number of messages posted to their wall per day is 10
\item A users avarage number of friends is 100 (each and every friend represents
one key exchange)
\item A users avarage private message (to single user) is 50 characters
\item A users avarage number of private (to single user) messages per day is 300
\end{itemize}
With these generous estimates, each user would generate (200*10*100)+(50*300*1)
bytes of raw data per day. Assuming a 10\% protocol overhead we would see
236,500 bytes of data per day per user.\\

The storage space required for a server is therfore 86MB per year per user. On a
server with 50,000 users that has been running for 3 years, there would be just
1.3TB of data.\\

Every time a client connects, it must download all messages posted since it last
connected to the server. To mitigate this we may run as a daemon on linux, or a
background process in windows, that starts when the user logs in. If we can
expect a computer to be turned on for just 4 hours a day then 20 hours of data
must be downloaded. ((236,500*no\_of\_users)/24)*hours\_off\_per\_day bytes must be
downloaded when the users computer is turned on.

The following table shows the delays between the computer turning on, and every
message having been downloaded (assuming a download speed of 500KB/second, and a
netowrk of 1000 users).

\begin{table}[h]
    \centering
    \begin{tabular}{lc}
    Hours off per day & Minutes to sync       \\ \hline
    0                 &  0 \\
    4                 &  1.3\\
    10                &  3.2\\
    12                &  3.9\\
    16                &  5.2\\
    20                &  6.5\\
    \end{tabular}
    \caption{Hours a computer is turned off per day vs minutes to sync}
\end{table}

To mitigate this, posts will be downloaded in reverse order, so that more recent
posts are downloaded first. We feel that waiting 2-5 mins is an acceptable delay
for the degree of privacy provided. Once the user is synced after turning their
computer on, no further delays will be incurred until the computer is shut down.

Due to the inherantly limited network size (\textless1500 users of one server is
practical) we recomend a number of smaller servers, each serving either a
geographic location, or a specific interest group.

\section{Task Partitioning}
\begin{itemize}
\item D. Breslin
    \begin{itemize}
    \item Task 1\todo{Replace task partitioning placeholders}
    \item Task 3
    \end{itemize}
\item L. Thomas
    \begin{itemize}
    \item Task 2
    \item Task 4
    \end{itemize}
\end{itemize}

\section{Proposed Tools}
Git, with a central (private) repository hosted on github will be used for
version control. The language used has yet to be decided..\todo{choose
programming language}.\todo{Talk more about tools, specifically about
communication between group members}

\section{Deliverables}
\begin{itemize}
\item Protocol documentation for developers writing third party clients
\item Windows and Linux executable: client
\item Windows and Linux executable: server
\item Full source for server, client, and any associated works\todo{update with
names of associated works as project continues}
\end{itemize}
